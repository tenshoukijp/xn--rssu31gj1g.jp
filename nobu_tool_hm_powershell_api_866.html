%(hilight)s
<h2><i class="fa fa-book fa-fw"></i>hmPSが持つ特別な関数一覧</h2>

<ul class="checklist">
    <li>
    <h3>ヒアドキュメント</h3>
    <p>hmPSの機能ではなく、秀丸マクロの機能となりますが、hmPSと関係が深いものとして、<br>
    秀丸エディタ 8.66では、C++の「R""」やC#の「@」のようなものが秀丸マクロで利用可能となっています。</p>
    <p>このため、秀丸マクロ内に、PowerShellをそのまま直接書き込めるようになりました。<br>
    これは非常に大きなメリットと言えるでしょう。<br>
    </p>
    <p>又、8.66以前のバージョンでは秀丸マクロの文字列リテラル(べた書きの文字列)の最大長は4Kバイトでしたが、<br>
    8.66以降では、64Kバイトとなりました。<br>
    これは、「連続1500行程度のPowerShellをマクロ内に直接張り付けることが出来る」ことを意味します。<br>
    </p>
    <li>
    <h3>デバッグ用途関数</h3>
    <p>デバッグ用途として以下の関数を利用し、「秀丸デバッグモニター」などに値や文字列を表示されることが出来ます。</p>
    <ul class="pointlist">
        <li>
        <h4>$hm::debuginfo( 文字列 )</h4>
        <p>対象の文字列を、システムデバッガへと文字列を転送します。<br>
        「秀丸デバッグモニター」などに値や文字列を確認することが可能です。</p>
    </ul>
    <li>
    <h3>編集中エディタに対する関数</h3>
    <p>現在秀丸エディタで開いているテキストに対して、以下の関数を利用することが出来ます。</p>
    <ul class="pointlist">
        <li>
        <h4>テキスト全体</h4>
        <ul class="arrowlist">
            <li>
            <h5>$hm::Edit::TotalText</h5>
            <p>現在編集中の秀丸エディタのテキスト全体を得る</p>
            <li>
            <h5>$hm::Edit::TotalText = "文字列"</h5>
            <p>現在編集中の秀丸エディタのテキスト全体を、文字列へと変更する</p>
        </ul>
        <div class="code"><pre class="brush:ps">
#PS = loaddll( hidemarudir + @&quot;\hmPS.dll&quot; );

#_ = dllfuncw( #PS, &quot;DoString&quot;, R&quot;PowerShell(
$totaltext = $hm::Edit::TotalText;
$hm::debuginfo($totaltext);

$hm::Edit::TotalText = &quot;あいうえお&quot;;
)PowerShell&quot;);

freedll( #PS );
</pre></div>
        <li>
        <h4>選択中のテキスト</h4>
        <p>(単純選択のみが対象となります。ボックス選択や複数選択は対象にはなりません)</p>
        <ul class="arrowlist">
            <li>
            <h5>$hm::Edit::SelectedText</h5>
            <p>現在編集中の秀丸エディタの「選択している」テキストを得る。</p>
            <li>
            <h5>$hm::Edit::SelectedText = "文字列"</h5>
            <p>現在編集中の秀丸エディタの「選択している」テキストを、"文字列"へと置き換える。</p>
        </ul>
        <div class="code"><pre class="brush:ps">
#PS = loaddll( hidemarudir + @&quot;\hmPS.dll&quot; );

#_ = dllfuncw( #PS, &quot;DoString&quot;, R&quot;PowerShell(
# 何かを単純選択していたら、テキストが得られる
$selectedtext = $hm::Edit::SelectedText;
$hm::debuginfo($selectedtext);

$hm::Edit::SelectedText = &quot;選択しているテキストをこの文字列に置き換えた&quot;;

)PowerShell&quot;);

freedll( #PS );
</pre></div>
        <li>
        <h4>カーソルがある行のテキスト</h4>
        <ul class="arrowlist">
            <li>
            <h5>$hm::Edit::LineText</h5>
            <p>現在編集中の秀丸エディタの「カーソルがある行」のテキストを得る。</p>
            <li>
            <h5>$hm::Edit::LineText = "文字列"</h5>
            <p>現在編集中の秀丸エディタの「カーソルがある行」のテキストを、文字列へと置き換える。<br>
        </ul>
        <div class="code"><pre class="brush:js">
#PS = loaddll( hidemarudir + @&quot;\hmPS.dll&quot; );

#_ = dllfuncw(  #PS, &quot;DoString&quot;, R&quot;PowerShell(
$linetext = $hm::Edit::LineText;
$hm::debuginfo($linetext);

# 行のテキストを入れ替える感じにするなら、最後に「\n」を付けること。
$hm::Edit::LineText = &quot;カーソル行のテキストをこれに変更\n&quot;;
)PowerShell&quot;);

freedll( #PS );
</pre></div>
        <li>
        <h4>カーソルの位置</h4>
        <ul class="arrowlist">
            <li>
            <h5>$hm::Edit::CursorPos.lineno</h5>
            <p>現在選択中の秀丸エディタのカーソル位置の行番号を得る。<br>
            秀丸マクロのlinenoと同じ値。</p>
            <li>
            <h5>$hm::Edit::CursorPos.column</h5>
            <p>現在選択中の秀丸エディタのカーソル位置のカラム値を得る。<br>
            秀丸マクロのcolumnと同じ値。</p>
        </ul>
        <div class="code"><pre class="brush:js">
#PS = loaddll( hidemarudir + @&quot;\hmPS.dll&quot; );

#_ = dllfuncw(  #PS, &quot;DoString&quot;, R&quot;PowerShell(
$lineno = $hm::Edit::CursorPos.lineno;
$column = $hm::Edit::CursorPos.column;
$hm::debuginfo( [string]$lineno + &quot;,&quot; + [string]$column );
)PowerShell&quot;);

freedll( #PS );
</pre></div>
    </ul>
    <li>
    <h3>PowerShellから秀丸マクロへアクセスする関数</h3>
    <p>PowerShellの機能をフルに生かしつつ、秀丸マクロの機能や各種値もほぼ全て使えるところが、<br>
    hmPSが優れている所以です。</p>
    <ul>
        <li>秀丸マクロをそのまま実行
        <li>「秀丸マクロの変数」⇔「PowerShellの変数」を相互にやり取り。
    </ul>
    <p>の２つの手段で秀丸マクロを取り扱うことが出来ます。</p>
    <ul class="pointlist">
        <li>
        <h4>PowerShellから秀丸マクロを実行</h4>
        <p>秀丸エディタ 8.66以降では、Hidemaru_EvalMacroという関数が秀丸本体からエキスポートされたため、<br>
        マクロ実行中であれば、秀丸マクロ以外の場所からでもマクロを記述し、実行することが可能となりました。</p>
        <ul class="arrowlist">
            <li>
            <h5>$hm::Macro::Eval( ヒアドキュメント文字列)</h5>
            <p>引数の文字列を、「秀丸マクロ」として実行する。</p>
        </ul>
        <div class="code"><pre class="brush:ps">
#PS = loaddll( hidemarudir + @&quot;\hmPS.dll&quot; );

if ( !#PS ) {
    message(&quot;hmPS.dllが導入されていません&quot;);
    endmacro;
}

#_ = dllfuncw(#PS, &quot;DoString&quot;, R&quot;PowerShell(

#PowerShellの中で、$hm::Macro::Eval関数を使って、秀丸のマクロを書くことが出来る
$hm::Macro::Eval( @'
  #a = 3;
  debuginfo 1;
  showvars;
  message(&quot;あいうえお&quot;);

  showvars;
'@
);

)PowerShell&quot;
);

freedll( #PS );
</pre></div>
        <li>
        <h4>PowerShellから秀丸マクロの変数の読み書き</h4>
        <ul class="arrowlist">
            <li>
            <h5>$hm::Macro::Var["変数名"]</h5>
            <p>対象の「秀丸マクロ」としてのシンボル名に対応する値を取得する。</p>
            <li>
            <h5>$hm::Macro::Var["変数名"] = 新たな値</h5>
            <p>対象の「秀丸マクロ」としてのシンボル名に、新たな値を設定する。<br>
            (読み取り専用の値には設定出来ません）</p>
        </ul>
        <div class="code"><pre class="brush:ps">
#PS = loaddll( hidemarudir + @&quot;\hmPS.dll&quot; );

#_ = dllfuncw(  #PS, &quot;DoString&quot;, R&quot;PowerShell(

# 秀丸マクロの「#aaa」という変数に3を設定。
$hm::Macro::Var['#aaa'] = 3;

# 秀丸マクロの「$bbb」という変数に「あいうえお」を設定。
$hm::Macro::Var['$bbb'] = &quot;あいうえお。&quot;

# 秀丸マクロとして一連の文字列を実行
$hm::Macro::Eval( @'
    message($bbb);
    $$message = $bbb + $bbb;
    message($$message);

    // アウトプット枠へ出力
    #OP = loaddll(&quot;HmOutputPane.dll&quot;);
    #ret = dllfunc(#OP, &quot;Output&quot;,hidemaruhandle(0), $$message);
    freedll(#OP);
'@
);

$hm::debuginfo( $hm::Macro::Var['$bbb'] );
$hm::debuginfo( $hm::Macro::Var['filename'] );

$hmdate = $hm::Macro::Var['date'];
$hm::debuginfo( $hmdate );

)PowerShell&quot;
);

freedll( #PS );
        </pre></div>
        <p>上記の例はさほど意味がある例題ではありませんが、 実践では「フォーム系」を使ったPowerShell層で、<br>
        「フォームを閉じることなく、イベントハンドラに呼応する形で(フォームを閉じることなく)秀丸を制御したい場合」などに威力を発揮することでしょう。 <br>
        又、ループを伴った値の伝達なども、秀丸マクロ層でやるよりも、PowerShell層でやった方が記述が簡潔に済みます。</p>
             <div class="code"><pre class="brush:ruby">
#PS = loaddll( hidemarudir + @&quot;\hmPS&quot; );

#_ = dllfuncw( #PS, &quot;DoString&quot;, R&quot;PS(
[System.Reflection.Assembly]::LoadWithPartialName(&quot;System.Windows.Forms&quot;)

class MyForm {
    [int] $counter;
    [System.Object] $form
    [System.Object] $btn

    SetForm() {
        $this.form = New-Object System.Windows.Forms.Form;
        $this.form.Text = &quot;こんにちわ&quot;;
    }

    SetButton() {
        $this.btn = New-Object System.Windows.Forms.Button;
        $this.btn.Text = &quot;クリック&quot;;
        $this.btn.Left = 16;
        $this.btn.Top = 16;
        $this.btn.Width = 100;
        $this.btn.Height = 40;
        $this.btn.Tag = $this;

        # イベントハンドラも作れる
        $this.btn.Add_Click({
            ($sender, $event) = ($this, $_);
            btn_Click($sender, $event);
        });

        $this.form.Controls.Add($this.btn);
    }

    Show() {
        $this.counter = 0;
        $this.SetForm();
        $this.SetButton();
 
        $this.form.ShowDialog();
    }

}


function btn_Click($sender, $event) {
    $sender.Tag.counter++;

    # デバッグモニター用の関数
    $hm::debuginfo(&quot;ボタンが押されたよ!!&quot;);
    $hm::debuginfo($sender.Tag.counter);

    # 秀丸マクロの「変数」とのやりとりも自由自在
    ($filename2) = $hm::Macro::Var['filename2'];
    $hm::debuginfo($filename2);

    # 秀丸マクロの「変数」とのやりとりも自由自在
    $hm::Macro::Var['$counter'] = [string]$sender.Tag.counter
    # PowerShellの中から秀丸マクロを一連のコマンドとして実行することも出来る。
    # PowerShellには「ヒアドキュメント」が使えるのでちょうどよい
    $hm::Macro::Eval(
@'
        // アウトプット枠へ出力
        #OP = loaddll(&quot;HmOutputPane.dll&quot;);
        #ret = dllfunc(#OP, &quot;Output&quot;,hidemaruhandle(0), $counter);
        freedll(#OP);
'@  );
    }



$f = New-Object MyForm;
$f.Show();

)PS&quot;
);

freedll(#PS);
        </pre></div>

    </ul>

    <li>
    <h3>$hmはグローバル</h3>
        <p>「$hm::Edit::***」や「$hm::Macro::***」ではアクセスできない場合、
            「::$hm::Edit::***」や「::$hm::Macro::***」など、頭に「::」を付け、<br>
            大域変数へのアクセスであることを明示する必要があります。
        </p>
    <li>
    <h3>DestroyScope関数</h3>
    <p>PowerShell内に「DestroyScope」という名前の関数を用意しておくと、<br>
    マクロ終了時に自動的にその関数が実行されます。</p>
    <div class="code"><pre class="brush:ps">
#PS = loaddll( hidemarudir + @&quot;\hmPS.dll&quot; );

#_ = dllfuncw( #PS, &quot;DoString&quot;, R&quot;PS(
function DestroyScope() {
  $hm::debuginfo(&quot;マクロ終了する直前に自動的にこの関数が呼び出される。&quot;);
}

)PS&quot;
);

freedll(#PS);
</pre></div>
    <li>
    <h3>簡易なHTMLエンコードの例</h3>
    <div class="code"><pre class="brush:python">
#PS = loaddll( hidemarudir + @&quot;\hmPS.dll&quot; );

if (! #PS) {
  message(&quot;hmPSが導入されいません。&quot;);
  endmacro;
}

#_ = dllfuncw( #PS, &quot;DoString&quot;, R&quot;PowerShell(
[System.Reflection.Assembly]::LoadWithPartialName(&quot;System.Web&quot;)

$html = [System.Web.HttpUtility]::HtmlEncode($hm::Edit::TotalText)
$html = $html.Replace(&quot;\r\n&quot;, &quot;\r&quot;)
$html = $html.Replace(&quot;\n&quot;, &quot;\r&quot;)
$html = $html.Replace(&quot;\r&quot;, &quot;&lt;br&gt;\r\n&quot;)
$html = $html.Replace(&quot;  &quot;, &quot; &amp;nbsp;&quot;)

$hm::Edit::TotalText = $html

)PowerShell&quot;
);

freedll( #PS );
</pre></div>

</ul>