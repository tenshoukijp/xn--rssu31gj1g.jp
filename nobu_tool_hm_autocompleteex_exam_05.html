%(hilight)s
<h2><i class="fa fa-book fa-fw"></i>チュートリアル⑤ ～編集中のテキスト～</h2>

<ul class="checklist">
    <li>
    <h3>概要</h3>
    <p>前節では、辞書や保存済みのファイルを分析し、説明文として表示しました。<br>
    しかし、<b>本来表示するべきなのは、「保存済みのファイル」の分析結果ではなく、</b><br>
    編集中のファイルの分析結果である、というのが理想です。</p>

    <li>
    <h3>秀丸 ver 8.66以降実現可能となった秀丸エディタで編集中データへの直接の問い合わせ</h3>
    <p>秀丸エディタ ver 8.66からは編集中のデータをネイティブ層で直接取得することが可能となりました。<br>
    又、カーソルの位置もネイティブ層から直接取得が可能となりました。</p>
    <li>
    <h3>ファイルの分析→編集中のテキストの分析へと変更</h3>
    <div class="code"><pre class="brush:cpp;">
#include &lt;windows.h&gt;
#include &quot;OutputDebugStream.h&quot;

#include &lt;msclr/marshal.h&gt;

using namespace std;

using namespace System;
using namespace System::IO;

using namespace System::Collections::Generic;

using namespace System::Text;
using namespace System::Text::RegularExpressions;

using namespace System::Drawing;
using namespace System::Windows::Forms;

using namespace msclr::interop;


public ref class ACHelpForm : public Form
{
public:
  static ACHelpForm^ f; // 自分自身の置き場

private:
  HWND hWnd;
  Label^ label;     // 説明文用のラベル
  int nTickRemainCnt;
  static Timer^ timer;

  static String^ dllFullPath;
  static String^ dicFullPath;
  static Dictionary&lt;String^, String^&gt;^ dic;

  // 秀丸本体からExportされている関数をセットする。
  static HMODULE hHidemaruExeInstance = GetModuleHandle(NULL);
  static HGLOBAL (WINAPI *GetTotalTextUnicode)(void)                      = (decltype(GetTotalTextUnicode))GetProcAddress(hHidemaruExeInstance, &quot;Hidemaru_GetTotalTextUnicode&quot;);
  static HGLOBAL (WINAPI *GetLineTextUnicode)(int nLineNo)                = (decltype(GetLineTextUnicode))GetProcAddress(hHidemaruExeInstance, &quot;Hidemaru_GetLineTextUnicode&quot;);
  static BOOL (WINAPI *GetCursorPosUnicode)(int* pnLineNo, int* pnColumn) = (decltype(GetCursorPosUnicode))GetProcAddress(hHidemaruExeInstance, &quot;Hidemaru_GetCursorPosUnicode&quot;);
  static BOOL (WINAPI *CheckQueueStatus)(void)                            = (decltype(CheckQueueStatus))GetProcAddress(hHidemaruExeInstance, &quot;Hidemaru_CheckQueueStatus&quot;);

public:
  ACHelpForm()
  {
    this-&gt;Visible = false;
    this-&gt;BackColor = System::Drawing::Color(::Color::White);

    SetFormAttr();

    label = gcnew Label();
    label-&gt;Top = 10;
    label-&gt;Left = 10;

    this-&gt;Controls-&gt;Add(label);

    // ディクショナリオブジェクト生成
    dic = gcnew Dictionary&lt;String^, String^&gt;();
    LoadDicFile();
    LoadCurText();
  }

  void LoadDicFile() {
    dllFullPath = System::Reflection::Assembly::GetExecutingAssembly()-&gt;Location;
    // 自分自身のディクションナリ
    dicFullPath = Path::ChangeExtension(dllFullPath, &quot;.dic&quot;);

    IO::StreamReader^ sr;
    try {
      sr = gcnew IO::StreamReader(dicFullPath, ::Encoding::GetEncoding(932)); // 説明文のファイルはsjis(cp932)と決め打った

      String^ line = &quot;&quot;;
      // 読み込みできる文字がなくなるまで繰り返す
      while ((line = sr-&gt;ReadLine()) != nullptr) {
        Regex^ re = gcnew Regex(R&quot;(^(.+?)★(.+)$)&quot;); // キーと説明文の境界線は「★」にしておく
        Match^ m = re-&gt;Match(line);
        if (m-&gt;Success) {
          String^ keyword = m-&gt;Groups[1]-&gt;Value;
          String^ details = m-&gt;Groups[2]-&gt;Value;
          // キーも値も両方有効
          if (keyword &amp;&amp; details) {
            details = details-&gt;Replace(&quot;◆&quot;, &quot;\n&quot;); // 「◆」は改行記号に変えておく
            dic[keyword] = details;
          }
        }
      }

    }
    catch (Exception^ e) {
      Windows::Forms::MessageBox::Show(e-&gt;Message);
    }
    finally {
      if (sr) {
        sr-&gt;Close();
      }
    }
  }

  // 現在のカーソルのポジションを得る(１オリジン)
  Point^ GetCursorPos() {
    if (!GetCursorPosUnicode) {
      return gcnew Point(1, 1);
    }

    // ネイティブで秀丸エディタに問い合わせ
    int nLineNo = 0;
    int nColumn = 0;
    GetCursorPosUnicode(&amp;nLineNo, &amp;nColumn);
    // マネージドでPoint参照型にしておく
    Point^ p = gcnew Point(nLineNo, nColumn);
    return p;
  }

  void LoadCurText() {
    if (!GetTotalTextUnicode) {
      return;
    }
    Point^ p = GetCursorPos();
    OutputDebugStream(L&quot;カーソル位置 x:%d, y:%d\n&quot;, p-&gt;X, p-&gt;Y);

    String^ all = &quot;&quot;;

    // 現在編集中のテキストを得る
    HGLOBAL hGlobal = GetTotalTextUnicode();
    if (hGlobal) {
      // ネイティブでピンポインタ状態で得る
      wchar_t* pwsz = (wchar_t*)GlobalLock(hGlobal);
      // マネージドにコピー
      all = marshal_as&lt;System::String^&gt;(pwsz);
      // ネイティブは解放
      GlobalUnlock(hGlobal);
      GlobalFree(hGlobal);
    }

    try {

      Regex^ re = gcnew Regex(&quot;((^#.+?\n)+)sub\\s+([^\\s]+)&quot;, RegexOptions::Multiline); // 1行としてみなして
      MatchCollection^ mc = re-&gt;Matches(all);

      for each(Match^ m in mc) {
        GroupCollection^ groups = m-&gt;Groups;
        String^ keyword = groups[3]-&gt;Value;
        String^ details = groups[1]-&gt;Value;
        // キーも値も両方有効
        if (keyword &amp;&amp; details) {
          dic[keyword] = details;
        }
      }

    }
    catch (Exception^) {
    }
  }


public:
  void Update(HWND hWnd, int iListBoxSelectedIndex, String^ strListBoxSelectedItem, int iItemHeight)
  {
    this-&gt;hWnd = hWnd;
    this-&gt;SuspendLayout();
    AdjustToAutoComp();
    // フォームのサイズや位置を再配置

    // それに応じてラベルのサイズが決まる
    label-&gt;Width = this-&gt;Width - label-&gt;Left * 2;
    label-&gt;Height = this-&gt;Height - label-&gt;Top * 2;
    label-&gt;Font = gcnew System::Drawing::Font(&quot;ＭＳ 明朝&quot;, (float)iItemHeight*0.7f); // 1.5倍ぐらい

    try {
      label-&gt;Text = dic[strListBoxSelectedItem];
    }
    catch (Exception^) {
      label-&gt;Text = &quot;&quot;;
    }
    this-&gt;ResumeLayout();

    CreateDelayTimer();
  }

protected:
  // 入力補完ウィンドウの右に、幅約2倍、高さ160pxへと自分自身を移動
  void AdjustToAutoComp()
  {
    RECT rect;
    GetWindowRect(this-&gt;hWnd, &amp;rect);
    this-&gt;Left = rect.right + 24;
    this-&gt;Top = rect.top;
    this-&gt;Width = (rect.right - rect.left) * 2;
    this-&gt;Height = 160;

    DrawRectangle();
  }

  // フォームの外淵に沿って四角を描画
  void DrawRectangle()
  {
    Graphics^ g = this-&gt;CreateGraphics();
    Pen^ pen = gcnew Pen(::Color::Gray, 1);
    g-&gt;DrawRectangle(pen, 0, 0, this-&gt;Width - 1, this-&gt;Height - 1);
    delete pen;
    delete g;
  }

  // 入力補完などで状態が切り替わったら、6ミリx100回ぐらいはトライして、状態を追従し続ける。
  // 状態追従の安定化の一環
  void CreateDelayTimer()
  {
    if (timer) {
      timer-&gt;Stop();
    }

    timer = gcnew Timer();
    timer-&gt;Interval = 6;
    timer-&gt;Tick += gcnew EventHandler(this, &amp;ACHelpForm::TimerTick);
    timer-&gt;Start();
    nTickRemainCnt = 100;
  }

  void TimerTick(Object^ sender, EventArgs^ e)
  {
    AdjustToAutoComp();

    if (label-&gt;Text-&gt;Length &gt; 0) { // 単語が有効であれば
      this-&gt;Show();
    }
    else {
      this-&gt;Hide();
    }

    nTickRemainCnt--;
    if (nTickRemainCnt &lt; 0) {
      timer-&gt;Stop();
    }
  }

public:
  void StopTimer()
  {
    if (timer) {
      timer-&gt;Stop();
    }
  }

protected:
  void SetFormAttr() {
    //タイトルバーを消す
    this-&gt;ControlBox = false;
    this-&gt;Text = &quot;&quot;;
    this-&gt;FormBorderStyle = ::FormBorderStyle::None;
  }

  // フォーム表示時にアクティブにならないようにする
  property bool ShowWithoutActivation
  {
    virtual bool get() override
    {
      return true;
    }
  }

  // このフォームがクリックなどされた時にアクティブにならないようにする。
  virtual void WndProc(Message %m) override
  {
    if (m.Msg == WM_MOUSEACTIVATE)
    {
      m.Result = (IntPtr)MA_NOACTIVATE;
      return;
    }

    Form::WndProc(m);
  }

};



extern &quot;C&quot; __declspec(dllexport) int OnCreate(HWND hWnd, LPCTSTR szFileName) {

  // ウィンドウの作成
  if (ACHelpForm::f == nullptr || ACHelpForm::f-&gt;IsDisposed) {
    ACHelpForm::f = gcnew ACHelpForm();
  }

  return TRUE;
}

extern &quot;C&quot; __declspec(dllexport) int OnListBoxSelectedIndexChanged(HWND hWnd, int iListBoxSelectedIndex, LPCTSTR szListBoxSelectedItem, int iItemHeight) {

  ACHelpForm::f-&gt;Update(hWnd, iListBoxSelectedIndex, gcnew String(szListBoxSelectedItem), iItemHeight);

  return TRUE;
}


extern &quot;C&quot; __declspec(dllexport) int OnDestroy(HWND hWnd) {

  // ウィンドウの破棄
  if (ACHelpForm::f) {
    ACHelpForm::f-&gt;StopTimer();
    ACHelpForm::f-&gt;Close();
  }

  // 明示的に解放
  if (ACHelpForm::f) {
    delete ACHelpForm::f;
  }

  return TRUE;

}
</pre></div>
    <li>
    <h3>解説</h3>
    <p>「LoadCurText」まわりが今回の注目点でしょう。<br>
    コンストラクタにて、「Hidemaru.exe」本体からExportされている関数群をセットしています。</p>
    <p>セットした関数を利用して、「カーソルの位置」や「現在編集中のテキスト」を取得しています。</p>
    <div class="code"><pre class="brush:cpp;">
  // 秀丸本体からExportされている関数をセットする。
  static HMODULE hHidemaruExeInstance = GetModuleHandle(NULL);
  static HGLOBAL (WINAPI *GetTotalTextUnicode)(void)                      = (decltype(GetTotalTextUnicode))GetProcAddress(hHidemaruExeInstance, &quot;Hidemaru_GetTotalTextUnicode&quot;);
  static HGLOBAL (WINAPI *GetLineTextUnicode)(int nLineNo)                = (decltype(GetLineTextUnicode))GetProcAddress(hHidemaruExeInstance, &quot;Hidemaru_GetLineTextUnicode&quot;);
  static BOOL (WINAPI *GetCursorPosUnicode)(int* pnLineNo, int* pnColumn) = (decltype(GetCursorPosUnicode))GetProcAddress(hHidemaruExeInstance, &quot;Hidemaru_GetCursorPosUnicode&quot;);
  static BOOL (WINAPI *CheckQueueStatus)(void)                            = (decltype(CheckQueueStatus))GetProcAddress(hHidemaruExeInstance, &quot;Hidemaru_CheckQueueStatus&quot;);

  ・・・

  // 現在のカーソルのポジションを得る(１オリジン)
  Point^ GetCursorPos() {
    if (!GetCursorPosUnicode) {
      return gcnew Point(1, 1);
    }

    // ネイティブで秀丸エディタに問い合わせ
    int nLineNo = 0;
    int nColumn = 0;
    GetCursorPosUnicode(&amp;nLineNo, &amp;nColumn);
    // マネージドでPoint参照型にしておく
    Point^ p = gcnew Point(nLineNo, nColumn);
    return p;
  }

  void LoadCurText() {
    if (!GetTotalTextUnicode) {
      return;
    }
    Point^ p = GetCursorPos();
    OutputDebugStream(L&quot;カーソル位置 x:%d, y:%d\n&quot;, p-&gt;X, p-&gt;Y);

    String^ all = &quot;&quot;;

    // 現在編集中のテキストを得る
    HGLOBAL hGlobal = GetTotalTextUnicode();
    if (hGlobal) {
      // ネイティブでピンポインタ状態で得る
      wchar_t* pwsz = (wchar_t*)GlobalLock(hGlobal);
      // マネージドにコピー
      all = marshal_as&lt;System::String^&gt;(pwsz);
      // ネイティブは解放
      GlobalUnlock(hGlobal);
      GlobalFree(hGlobal);
    }

    try {

      Regex^ re = gcnew Regex(&quot;((^#.+?\n)+)sub\\s+([^\\s]+)&quot;, RegexOptions::Multiline); // 1行としてみなして
      MatchCollection^ mc = re-&gt;Matches(all);

      for each(Match^ m in mc) {
        GroupCollection^ groups = m-&gt;Groups;
        String^ keyword = groups[3]-&gt;Value;
        String^ details = groups[1]-&gt;Value;
        // キーも値も両方有効
        if (keyword &amp;&amp; details) {
          dic[keyword] = details;
        }
      }

    }
    catch (Exception^) {
    }
  }

</pre></div>
    <li>
    <h3>再度コンパイル</h3>
    <p>再度コンパイルし、「HmAutoCompleteExPlug.dll」を秀丸ディレクトリにコピーしましょう。<br>
    <p>再び、.plファイルを読み込んで、何か入力補完を出し、単語を選択してみましょう。<br>
    以下のように、「本当の意味での編集中」のコメント説明文が表示されたでしょうか。<br>
    </p>
    <p><img src="./other_soft/hm_autocompleteex/hm_autocompleteex_exam_11.png"></p>
</ul>