%(hilight)s
<h2><i class="fa fa-book fa-fw"></i>C#などで作った外部の「マネージドな.dll」の読み込み</h2>

<ul class="checklist">
    <li>
    <h3>概要</h3>
    <p>一般論の話をしますと、「C#」「VB.net」「C++/CLI」「F#」「JScript.net」などで作成したdllを「マネージドなアセンブリdll」として読み込む場合、<br>
    普通なら「<span class="negative">読み込み対象となるdllファイル置き場の位置に大きな制約</span>」があるのです。(ネットなどで調べてみてください)<br>
    特殊な設定でもしない限り、「exeと同じ場所か、dll名と同じ名前のサブフォルダに入れる」必要があります。<br>
    <br>
    <span class="positive">しかし、hmPS・PowerShellには</span><span class="negative"><b>そのような制限は一切ありません。<br>
    好きなフォルダに置いた自作のマネージドな.dllを(特に署名などもなく)突如自由に読みだして利用可能です。</b></span><br>
    </p>

    <h3>C#のソースから.dllを作成。</h3>
    <p>最小限のサンプルとするため、わかりやすい構成としましょう。<br>
    </p>
    <p>hmPS/PowerShell自体は、.NET Framework 4.0で構成されていますが、<br>
    あなたが利用する.dllは、<span class="negative">.NET Framework 4.6など、hmPSより新しいバージョンのアセンブリでも大丈夫</span>です!!<br>
    ここも普通の.NETの考え方の制限とは大きく異なるとここです。<br>
    <span class="negative">あなたのPCに入っている.NET Frameworkの一番新しいバージョンで作成しても問題ありません。</span></p>
    <ul>
        <li>ファイル名は「TestSample.dll」
        <li>名前空間は「TestNameSpace」
        <li>クラス名は「TestClass」
        <li>メソッドは「TestFunc」
    </ul>
    <p>とします。</p>
    <p>コンパイルし、<span class="positive">TestSample.dll</span>といった名前にしたとしましょう。</p>
    <div class="code"><pre class="brush:csharp">
using System;

namespace TestNameSpace
{
    public class TestClass
    {
        public TestClass() { }
        public int TestFunc(int x)
        {
            return x + 3;
        }
    }
}
</pre></div>

    <h3>C#等のアセンブリをloadする例</h3>
    <p>PowerShellは、普通にユーザーが制作したC#を読み込めますので、適当に読み込めば良いでしょう。<br>
    <br>
    ファイル名は、適当に「loaddlltest.mac」とでもしてみましょう。</p>

    <div class="code"><pre class="brush:ps">
#PS = loaddll( hidemarudir + &quot;\\&quot; + &quot;hmPS.dll&quot; );

#_ = dllfuncw(#PS, &quot;DoString&quot;, R&quot;PS(

$AssemblyPath.Add( $hm::Macro::Var['currentmacrodirectory'] )
[System.Reflection.Assembly]::LoadWithPartialName(&quot;TestSample&quot;)

$obj = New-Object TestNameSpace.TestClass
$hm::debuginfo($obj);
$total = $obj.TestFunc(10)

$hm::Macro::Var['#total'] = $total;

$hm::debuginfo($total)


)PS&quot;
);

// 解放
freedll(#PS);</pre></div>


    <h3>好きなフォルダに置く</h3>
    <p>以上、TestSample.dllとTestつのファイルを好きなフォルダ(秀丸と一切関係ないフォルダでもよい)に置いて、<br>
    「loaddlltest.mac」を適当に秀丸に登録して実行してみてください。<br>
    .dllが読みだされ計算結果がダイアログに表示されるハズです。<br>
    </p>
    <p><img src="./other_soft/hm_powershell/cnt_hm_powershell_20.png"></p>


    <h3>currentmacrodirectoryはアセンブリの読み込み対象に入っている</h3>
    <p>先述の例では、より正確な例を示すために、「$AssemblyPath.Add(...)」を使った例を示しました。<br></p>
    <p>hmPSでは、<span class="positive">実行するマクロファイルと同じ場所(currentmacrodirectory)に、読み込み対象の.dllがある場合、<br>
    $AssemblyPathにcurrentmacrodirectoryをAddする必要はありません。</span><br>
    </p>
    <p>以下のように簡潔な記述が可能です。</p>
    <div class="code"><pre class="brush:ps">
#PS = loaddll( hidemarudir + @&quot;\hmPS.dll&quot; );

#_ = dllfuncw( #PS, &quot;DoString&quot;, R&quot;PowerShell(

[System.Reflection.Assembly]::LoadWithPartialName(&quot;TestSample&quot;)

$obj = New-Object TestNameSpace.TestClass
$hm::debuginfo($obj);
$total = $obj.TestFunc(10)

$hm::Macro::Var['#total'] = $total;

$hm::debuginfo($total)


$hm::Macro::Eval( @'
    message(str(#total));
'@
);

)PowerShell&quot;
);

freedll( #PS );
</pre></div>
</ul>