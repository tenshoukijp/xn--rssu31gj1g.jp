%(hilight)s
<h2><i class="fa fa-book fa-fw"></i>C#などで作った外部の「マネージドな.dll」の読み込み</h2>

<ul class="checklist">
    <li>
    <h3>概要</h3>
    <p>一般論の話をしますと、「C#」「VB.net」「C++/CLI」「F#」「JScript.net」などで作成したdllを「マネージドなアセンブリdll」として読み込む場合、<br>
    普通なら「<span class="negative">読み込み対象となるdllファイル置き場の位置に大きな制約</span>」があるのです。(ネットなどで調べてみてください)<br>
    特殊な設定でもしない限り、「exeと同じ場所か、dll名と同じ名前のサブフォルダに入れる」必要があります。<br>
    <br>
    <span class="positive">しかし、hmRb・IronRubyには</span><span class="negative"><b>そのような制限は一切ありません。<br>
    好きなフォルダに置いた自作のマネージドな.dllを(特に署名などもなく)突如自由に読みだして利用可能です。</b></span><br>
    </p>

    <h3>C#のソースから.dllを作成。</h3>
    <p>最小限のサンプルとするため、わかりやすい構成としましょう。<br>
    </p>
    <p>hmRb/IronRuby自体は、.NET Framework 4.0で構成されていますが、<br>
    あなたが利用する.dllは、<span class="negative">.NET Framework 4.6など、hmRbより新しいバージョンのアセンブリでも大丈夫</span>です!!<br>
    ここも普通の.NETの考え方の制限とは大きく異なるとここです。<br>
    <span class="negative">あなたのPCに入っている.NET Frameworkの一番新しいバージョンで作成しても問題ありません。</span></p>
    <ul>
        <li>ファイル名は「TestSample.dll」
        <li>名前空間は「TestNameSpace」
        <li>クラス名は「TestClass」
        <li>メソッドは「TestFunc」
    </ul>
    <p>とします。</p>
    <p>コンパイルし、<span class="positive">TestSample.dll</span>といった名前にしたとしましょう。</p>
    <div class="code"><pre class="brush:csharp">
using System;

namespace TestNameSpace
{
    public class TestClass
    {
        public TestClass() { }
        public int TestFunc(int x)
        {
            return x + 3;
        }
    }
}
</pre></div>

    <h3>loadするIronRubyの例</h3>
    <p>$LOAD_PATH.push(...)をすることで、該当のパスに.dllを置いた場合に読み込み可能となります。<br>
    後は、普段通り、require 関数を利用して読み込みましょう。<br>
    <br>
    ファイル名は、適当に「loaddll.rb」とでもしてみましょう。</p>

    <div class="code"><pre class="brush:ruby">
# coding: utf-16
require 'mscorlib'
require &quot;System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot;

$currentmacrodirectory = $hm.Macro.Var['currentmacrodirectory']
$LOAD_PATH.push($currentmacrodirectory.to_s)  #.NETの文字列とRubyの文字列では差異がある。to_sを入れる必要がある。
#「$LOAD_PATH」ではなく、「$:」という特殊変数を使っても同じこと
# 高い優先順位でcurrentmacrodirectoryを加えるなら、pushの替わりに、unshiftを利用してください。

require 'TestSample'


$obj = TestNameSpace::TestClass.new
$total = $obj.TestFunc(10)
$loadclass = TestNameSpace::TestClass.to_s

$hm.Macro.Var['#total'] = $total;
$hm.Macro.Var['$loadclass'] = $loadclass;


$hm.debuginfo($total)
</pre></div>

    <h3>秀丸マクロに記述する.mac</h3>
    <p>一般的には、実行するマクロと同じ場所にdllを置くのが良いでしょうから、<br>
    このように「currentmacrodirectory」をIronRubyに渡して利用するのがテンプレートの１つとなるでしょう。<br>
    <br>
    マクロ名は適当に「loaddlltest.mac」とでもしてみましょう。</p>

    <div class="code"><pre class="brush:ruby">
#RB = loaddll( hidemarudir + &quot;\\&quot; + &quot;hmRb.dll&quot; );

#_ = dllfuncw(#RB, &quot;DoFile&quot;, currentmacrodirectory + &quot;\\loaddll.rb&quot;);

message(str(#total));
message($loadclass );

freedll( #RB );
</pre></div>

    <h3>好きなフォルダに置く</h3>
    <p>以上３つのファイルを好きなフォルダ(秀丸と一切関係ないフォルダでもよい)に置いて、<br>
    「loaddlltest.mac」を適当に秀丸に登録して実行してみてください。<br>
    .dllが読みだされ計算結果がダイアログに表示されるハズです。<br>
    </p>
    <p><img src="./other_soft/hm_ironpython/cnt_hm_ironpython_20.png"></p>


    <h3>マクロ内に手軽に簡易記述</h3>
    <p>先述の例では、説明のために、ファイルを２つに分けた例を提示しました。<br></p>
    <p>hmRbでは、<span class="positive">実行するマクロファイルと同じ場所(currentmacrodirectory)に、読み込み対象の.dllがある場合、<br>
    $LOAD_PATH にcurrentmacrodirectoryをpushする必要はありません。</span><br>
    </p>
    <p>以下のように簡潔な記述が可能です。</p>
    <div class="code"><pre class="brush:ruby">
#RB = loaddll( hidemarudir + @&quot;\hmRb.dll&quot; );

#_ = dllfuncw( #RB, &quot;DoString&quot;, R&quot;IRONRUBY(

require 'mscorlib'
load_assembly &quot;System&quot;
require 'TestSample' # load_assembly 'TestSample' でも同じ


$obj = TestNameSpace::TestClass.new
$total = $obj.TestFunc(10)
$loadclass = TestNameSpace::TestClass.to_s

$hm.Macro.Var['#total'] = $total;
$hm.Macro.Var['$loadclass'] = $loadclass;

$hm.debuginfo($total)

$hm.Macro.Eval(&lt;&lt;-'MACRO'
    message(str(#total));
    message($loadclass );
MACRO
);

)IRONRUBY&quot;
);

freedll( #RB );
</pre></div>
    <li>
    <h3>既存のRuby標準ライブラリや.NET標準ライブラリと名前が被らないように注意</h3>
    <p>Ruby標準ライブラリや.NET標準ライブラリと同じ名前の.dllやクラスを生成するのは<br>
    読み込み順番が少し変わっただけで挙動が変わるため、混乱のもとですのでやめましょう。<br>
    既存のライブラリとしてそれが存在するのかどうかは、以下のような形で軽い確認できます。</p>
    <p>ironrubyのコマンドラインで...</p>
    <div class="code"><pre class="brush:ps">
ir -rcmath -e ""
</pre></div>
<p>などとする</p>

    <div class="code"><pre class="brush:ps">
ir -rmylib -e ""
</pre></div>
<p>としてLoadErrorが出れば、それ(=mylib)は既存のライブラリには存在しない。</p>

    <div class="code"><pre class="brush:ps">
ir -rSystem -e ""
</pre></div>
<p>CLRのSystemが読まれるので、Errorが出ない。すなわち存在する。</p>
<p>より厳密なチェックをするならば、<br>
実際に、このページ内にある「require」や「load_assembly」と同様の記述にて、実際の存在を確認しましょう。</p>
    <p><img src="./other_soft/hm_ironruby/cnt_hm_ironruby_21.png"></p>

</ul>