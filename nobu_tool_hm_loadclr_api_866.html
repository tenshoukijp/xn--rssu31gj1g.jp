%(hilight)s
<h2><i class="fa fa-book fa-fw"></i>hmLoadCLRが持つ特別な関数一覧</h2>

<ul class="checklist">
    <li>
    <h3>ヒアドキュメント</h3>
    <p>hmLoadCLRの機能ではなく、秀丸マクロの機能となりますが、hmLoadCLRと関係が深いものとして、<br>
    秀丸エディタ 8.66では、C++の「R""」やC#の「@」のようなものが秀丸マクロで利用可能となっています。</p>
    <p>このため、秀丸マクロ内に、hmLoadCLR(Lua)をそのまま直接書き込めるようになりました。<br>
    これは非常に大きなメリットと言えるでしょう。<br>
    </p>
    <p>又、8.66以前のバージョンでは秀丸マクロの文字列リテラル(べた書きの文字列)の最大長は4Kバイトでしたが、<br>
    8.66以降では、64Kバイトとなりました。<br>
    これは、「連続1500行程度のhmLoadCLRをマクロ内に直接張り付けることが出来る」ことを意味します。<br>
    </p>
    <li>
    <h3>デバッグ用途関数</h3>
    <p>デバッグ用途として以下の関数を利用し、「秀丸デバッグモニター」などに値や文字列を表示されることが出来ます。</p>
    <ul class="pointlist">
        <li>
        <h4>hm.debuginfo( 文字列 )</h4>
        <p>対象の文字列を、システムデバッガへと文字列を転送します。<br>
        「秀丸デバッグモニター」などに値や文字列を確認することが可能です。</p>
    </ul>
    <li>
    <h3>編集中エディタに対する関数</h3>
    <p>現在秀丸エディタで開いているテキストに対して、以下の関数を利用することが出来ます。</p>
    <ul class="pointlist">
        <li>
        <h4>テキスト全体</h4>
        <ul class="arrowlist">
            <li>
            <h5>hm.Edit.TotalText</h5>
            <p>現在編集中の秀丸エディタのテキスト全体を得る</p>
            <li>
            <h5>hm.Edit.TotalText = "文字列"</h5>
            <p>現在編集中の秀丸エディタのテキスト全体を、文字列へと変更する</p>
        </ul>
        <div class="code"><pre class="brush:python">
#MNG = loaddll( hidemarudir + @&quot;\hmLoadCLR.dll&quot; );

#_ = dllfuncw( #MNG, &quot;DoString&quot;, R&quot;MNG(
totaltext = hm.Edit.TotalText;
hm.debuginfo(totaltext);

hm.Edit.TotalText = &quot;あいうえお&quot;;
)MNG&quot;);

freedll( #MNG );
</pre></div>
        <li>
        <h4>選択中のテキスト</h4>
        <p>(単純選択のみが対象となります。ボックス選択や複数選択は対象にはなりません)</p>
        <ul class="arrowlist">
            <li>
            <h5>hm.Edit.SelectedText</h5>
            <p>現在編集中の秀丸エディタの「選択している」テキストを得る。</p>
            <li>
            <h5>hm.Edit.SelectedText = "文字列"</h5>
            <p>現在編集中の秀丸エディタの「選択している」テキストを、"文字列"へと置き換える。</p>
        </ul>
        <div class="code"><pre class="brush:python">
#MNG = loaddll( hidemarudir + @&quot;\hmLoadCLR.dll&quot; );

#_ = dllfuncw( #MNG, &quot;DoString&quot;, R&quot;MNG(
-- 何かを単純選択していたら、テキストが得られる
selectedtext = hm.Edit.SelectedText;
hm.debuginfo(selectedtext);

hm.Edit.SelectedText = &quot;選択しているテキストをこの文字列に置き換えた&quot;;

)MNG&quot;);

freedll(  #MNG );
</pre></div>
        <li>
        <h4>カーソルがある行のテキスト</h4>
        <ul class="arrowlist">
            <li>
            <h5>hm.Edit.LineText</h5>
            <p>現在編集中の秀丸エディタの「カーソルがある行」のテキストを得る。</p>
            <li>
            <h5>hm.Edit.LineText = "文字列"</h5>
            <p>現在編集中の秀丸エディタの「カーソルがある行」のテキストを、文字列へと置き換える。<br>
        </ul>
        <div class="code"><pre class="brush:js">
#MNG = loaddll( hidemarudir + @&quot;\hmLoadCLR.dll&quot; );

#_ = dllfuncw(  #MNG, &quot;DoString&quot;, R&quot;MNG(
linetext = hm.Edit.LineText;
hm.debuginfo(linetext);

-- 行のテキストを入れ替える感じにするなら、最後に「\n」を付けること。
hm.Edit.LineText = &quot;カーソル行のテキストをこれに変更\n&quot;;
)MNG&quot;);

freedll(  #MNG );
</pre></div>
        <li>
        <h4>カーソルの位置</h4>
        <ul class="arrowlist">
            <li>
            <h5>hm.Edit.CursorPos.lineno</h5>
            <p>現在選択中の秀丸エディタのカーソル位置の行番号を得る。<br>
            秀丸マクロのlinenoと同じ値。</p>
            <li>
            <h5>hm.Edit.CursorPos.column</h5>
            <p>現在選択中の秀丸エディタのカーソル位置のカラム値を得る。<br>
            秀丸マクロのcolumnと同じ値。</p>
        </ul>
        <div class="code"><pre class="brush:js">
#MNG = loaddll( hidemarudir + @&quot;\hmLoadCLR.dll&quot; );

#_ = dllfuncw(  #MNG, &quot;DoString&quot;, R&quot;MNG(
lineno = hm.Edit.CursorPos.lineno;
column = hm.Edit.CursorPos.column;
hm.debuginfo( tostring(lineno) .. &quot;,&quot; .. tostring(column) );
)MNG&quot;);

freedll(  #MNG );
</pre></div>
    </ul>
    <li>
    <h3>hmLoadCLRから秀丸マクロへアクセスする関数</h3>
    <p>hmLoadCLRの機能をフルに生かしつつ、秀丸マクロの機能や各種値もほぼ全て使えるところが、<br>
    hmLoadCLRが優れている所以です。</p>
    <ul>
        <li>秀丸マクロをそのまま実行
        <li>「秀丸マクロの変数」⇔「hmLoadCLRの変数」を相互にやり取り。
    </ul>
    <p>の２つの手段で秀丸マクロを取り扱うことが出来ます。</p>
    <ul class="pointlist">
        <li>
        <h4>hmLoadCLRから秀丸マクロを実行</h4>
        <p>秀丸エディタ 8.66以降では、Hidemaru_EvalMacroという関数が秀丸本体からエキスポートされたため、<br>
        マクロ実行中であれば、秀丸マクロ以外の場所からでもマクロを記述し、実行することが可能となりました。</p>
        <ul class="arrowlist">
            <li>
            <h5>hm.Macro.Eval( ヒアドキュメント文字列)</h5>
            <p>引数の文字列を、「秀丸マクロ」として実行する。</p>
        </ul>
        <div class="code"><pre class="brush:python">
#MNG = loaddll( hidemarudir + @&quot;\hmLoadCLR.dll&quot; );

if ( !#MNG ) {
    message(&quot;hmPY.dllが導入されていません&quot;);
    endmacro;
}

#_ = dllfuncw(#MNG, &quot;DoString&quot;, R&quot;MNG(
py_x = 100

-- hmLoadCLR(Lua)の中で、hm.Macro.Eval関数を使って、秀丸のマクロを書くことが出来る
hm.Macro.Eval([[
  #a = 3;
  debuginfo 1;
  showvars;
  message(&quot;あいうえお&quot;);

  showvars;
]])

)MNG&quot;
);

freedll( #MNG );
</pre></div>
        <li>
        <h4>hmLoadCLRから秀丸マクロの変数の読み書き</h4>
        <ul class="arrowlist">
            <li>
            <h5>hm.Macro.Var["変数名"]</h5>
            <p>対象の「秀丸マクロ」としてのシンボル名に対応する値を取得する。</p>
            <li>
            <h5>hm.Macro.Var["変数名"] = 新たな値</h5>
            <p>対象の「秀丸マクロ」としてのシンボル名に、新たな値を設定する。<br>
            (読み取り専用の値には設定出来ません）</p>
        </ul>
        <div class="code"><pre class="brush:python">
#MNG = loaddll( hidemarudir + @&quot;\hmLoadCLR.dll&quot; );

#_ = dllfuncw(  #MNG, &quot;DoString&quot;, R&quot;MNG(

-- 秀丸マクロの「#aaa」という変数に3を設定。
hm.Macro.Var['#aaa'] = 3;

-- 秀丸マクロの「$bbb」という変数に「あいうえお」を設定。
hm.Macro.Var['$bbb'] = &quot;あいうえお。&quot;

-- 秀丸マクロとして一連の文字列を実行
hm.Macro.Eval( [[
    message($bbb);
    $$message = $bbb + $bbb;
    message($$message);

    // アウトプット枠へ出力
    #OP = loaddll(&quot;HmOutputPane.dll&quot;);
    #ret = dllfunc(#OP, &quot;Output&quot;,hidemaruhandle(0), $$message);
    freedll(#OP);
]]
);

hm.debuginfo( hm.Macro.Var['$bbb'] );
hm.debuginfo( hm.Macro.Var['filename'] );

hmdate = hm.Macro.Var['date'];
hm.debuginfo( hmdate );

)MNG&quot;
);

freedll(  #MNG );
        </pre></div>
        <p>上記の例はさほど意味がある例題ではありませんが、 実践では「フォーム系」を使ったhmLoadCLR層で、<br>
        「フォームを閉じることなく、イベントハンドラに呼応する形で(フォームを閉じることなく)秀丸を制御したい場合」などに威力を発揮することでしょう。 <br>
        又、ループを伴った値の伝達なども、秀丸マクロ層でやるよりも、hmLoadCLR層でやった方が記述が簡潔に済みます。</p>
    </ul>
    <li>
    <h3>DestroyScope関数が自動で呼び出される</h3>
    <p>多くのサンプルコードにおいて、秀丸マクロ内の最終部の「freedll」の直前にて</p>
    <div class="code"><pre class="brush:python">
#_ = dllfuncw(#MNG, &quot;DestroyScope&quot; );
</pre></div>
    <p>と「hmLoadCLRのスコープの破棄」が明示的に呼び出されています。<br>
    </p>
    <p>秀丸 v8.66以降では、<b>freedllだけ記述しておけば、DestroyScopeは自動的に呼び出されます。</b></p>
    <li>
    <h3>8.66の機能を利用した簡易なHTMLエンコードの例</h3>
    <div class="code"><pre class="brush:python">
#MNG = loaddll( hidemarudir + @&quot;\hmLoadCLR.dll&quot; );

if (! #MNG) {
  message(&quot;hmPYが導入されいません。&quot;);
  endmacro;
}

#_ = dllfuncw( #MNG, &quot;DoString&quot;, R&quot;MNG(
clr.System.Reflection.Assembly:Load(&quot;System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a&quot;)

html = clr.System.Web.HttpUtility.HtmlEncode(hm.Edit.TotalText)
html = html.Replace(&quot;\r\n&quot;, &quot;\r&quot;)
html = html.Replace(&quot;\n&quot;, &quot;\r&quot;)
html = html.Replace(&quot;\r&quot;, &quot;&lt;br&gt;\r\n&quot;)
html = html.Replace(&quot;  &quot;, &quot; &amp;nbsp;&quot;)

hm.Edit.TotalText = html

)MNG&quot;
);

freedll( #MNG );
</pre></div>
</ul>