%(hilight)s
<h2><i class="fa fa-book fa-fw"></i>秀丸エディタ・HmCustomLivePreviewのカスタム 中級編</h2>

<ul class="checklist">
    <li>
    <h3>概要</h3>
    <p>ここでは、前節「秀丸エディタ・HmCustomLivePreviewのカスタム 初級編」の続きです。</p>
    <li>
    <h3>HmCustomLivePreviewDefault.macの作成</h3>
    <p>それでは、HmCustomLivePreviewDefault.macをコピーして、HmCustomLivePreviewVar.macとしましょう。</p>
    <p>今回の話題は、hmJSの<a href="?page=nobu_tool_hm_javascript_api_866">hmJS専用の関数群</a>の中でも、<br>
    hm.Macro.Var(...)やhm.Macro.Eval(...)が使えるのか、使えないのかの問題と解説となります。</p>
    <li>
    <h3>HmCustomLivePreviewの「フォームの表示」と「マクロ中か否か」の問題</h3>
    <p>HmCustomLivePreviewの動作を確認してみましょう。<br>
    この理解は、JScriptで使える変数、使えない変数の理解する上で欠かせないものとなります。</p>
    <ul>
        <li>マクロの実行開始～フォームを閉じる(もしくは秀丸を閉じる)までを時間軸とすると、下図のようになります。<br>
        <img src="./other_soft/hm_customlivepreview/hm_customlivepreview_05.png" width="1000">
    </ul>
    <p>この中で、「秀丸マクロの変数やシンボル」へとアクセス可能なのは、「マクロ実行開始」～「マクロ終了」までです。<br>
    「HmCustomLivePreview」のフォームビューワーが表示された瞬間には、すでに「マクロは終了」しています。</p>
    <p><span class="negative"><b>マクロが実行しっぱなしだと、他のマクロが実行できず、不便ですのでこのようになっています。</b><br>
    (<b>秀丸マクロはマクロを複数同時に実行できないため、他のマクロ実行のさまたげとならないように、<br>
    このような苦肉の策が必要なのです</b>)</span></p>
    <p>このことは、下記のプログラムを実行してみればわかります。</p>
    <div class="code"><pre class="brush:python">
#dll = loaddll( currentmacrodirectory + @&quot;\HmCustomLivePreview.dll&quot; );
if (!#dll) {
  message(&quot;NO&quot;);
  endmacro;
}

#_ = dllfuncw( #dll, &quot;DoString&quot;, R&quot;JSCRIPT(

function OnCustomTranslateHTML(filename, rawtext) {

    return hm.Macro.Var("column").toString();
}

)JSCRIPT&quot;
);

#_ = dllfuncw( #dll, &quot;Show&quot;, hidemaruhandle(0) );
</pre></div>
    <p>これをHmCustomLivePreviewで見てみると、下図のようになります。<br>
    「一瞬だけcolumnに相当する数値」が出た後、次のTick以降は、秀丸のテキストまんまへと戻ってしまったハズです。</p>
    <p>秀丸デバッグモニターのエラーなどで確認すると</p>
    <p><img src="./other_soft/hm_customlivepreview/hm_customlivepreview_06.png"></p>
    <p>のようになっているのが確認できます。<br>
    先述したように、「HmCustomLivePreview」を表示した直後に「秀丸マクロ」としては終了してしまったので、<br>
    フォーム表示以降は、マクロ変数にはアクセスできないのです。</p>

    <li>
    <h3>秀丸の編集テキストのフォントを、そのままHmCustomLivePreviewへと伝達</h3>
    <p>それでは、hm.Macro.Var(...)の使い手は全くないのでしょうか？<br>
    そんなことはないと思われます、<br>
    </p>
    <p>確かにライブ情報としては使えないものの、「HmCustomLivePreview」の起動時に収集できる情報でも<br>
    十分に価値があるものも、中にはあることでしょう。</p>
    <p>例えば、プレビュー画面で利用されるフォントが、<br>
    現在秀丸で編集中の画面で利用しているフォントと同じもので描画する、<br>
    といったこともそのひとつでしょう。</p>
    <li>
    <h3>HmCustomLivePreviewFont.macの作成</h3>
    <p>それでは、HmCustomLivePreviewFont.macをコピーして、HmCustomLivePreviewFont.macを作成してみましょう。<br>
    </p>
    <div class="code"><pre class="brush:python">
#dll = loaddll( currentmacrodirectory + @&quot;\HmCustomLivePreview.dll&quot; );
if (!#dll) {
    message(&quot;NO&quot;);
    endmacro;
}

#_ = dllfuncw( #dll, &quot;DoString&quot;, R&quot;JSCRIPT(

// 秀丸でマクロ開始時点で使用されているフォント名の取得
// (OnCustomTranslateHTML関数の中では取得できないので、最初の１回ここで取得しておく)
var fontname = hm.Macro.Var(&quot;fontname&quot;);

function OnCustomTranslateHTML(filename, rawtext) {

    var htmltext = rawtext;
    htmltext = htmltext.replace( /&lt;/g, &quot;&amp;lt;&quot;);
    htmltext = htmltext.replace( /&gt;/g, &quot;&amp;gt;&quot;);
    htmltext = htmltext.replace( /\n/g, &quot;&lt;br&gt;&quot;);

    // 該当フォントのタグで、HTMLを囲む
    htmltext = &quot;&lt;font face='&quot;+fontname+&quot;'&gt;&quot; + htmltext + &quot;&lt;/font&gt;&quot;;
    return htmltext;
}


)JSCRIPT&quot;
);

#_ = dllfuncw( #dll, &quot;Show&quot;, hidemaruhandle(0) );
    </pre></div>
    <p>これをHmCustomLivePreviewで見てみると、下図のようになります。</p>
    <p><img src="./other_soft/hm_customlivepreview/hm_customlivepreview_09.png"></p>
    <p>秀丸上のフォント名がきっちりと反映されていることがわかるでしょう。</p>

    <li>
    <h3>選択中のテキストだけレンダリングする</h3>
    <p>次は、秀丸で編集しているテキスト全体ではなく、<br>
    「秀丸上で選択しているテキスト」だけを対象にレンダリングするようにします。<br>
    ライブビューですので「テキストの選択範囲を変更すれば」、描画内容が更新されるわけです。</p>
    <h3>HmCustomLivePreviewSelectImg.macの作成</h3>
    <p>HmCustomLivePreviewImg.macをコピーして、HmCustomLivePreviewSelectImg.macとしましょう。<br>
    そして、下図のハイライトの行だけを書き換えます。</p>
    <div class="code"><pre class="brush:python;highlight:[11]">
#dll = loaddll( currentmacrodirectory + @&quot;\HmCustomLivePreview.dll&quot; );
if (!#dll) {
  message(&quot;HmCustomLive&quot;);
  endmacro;
}

#_ = dllfuncw( #dll, &quot;DoString&quot;, R&quot;JSCRIPT(

function OnCustomTranslateHTML(filename, rawtext) {

    var htmltext = hm.Edit.SelectedText;
    htmltext = htmltext.replace( /&lt;/g, &quot;&amp;lt;&quot;);
    htmltext = htmltext.replace( /&gt;/g, &quot;&amp;gt;&quot;);
    htmltext = htmltext.replace( /\n/g, &quot;&lt;br&gt;&quot;);

    htmltext = htmltext.replace(/---/g, &quot;&lt;hr&gt;&quot; );
    // ここまでは前回までの話

    // 画像と思われる正規表現をあなた独自に定義する。
    // ここでは「a-zA-Z0-9_\/」のいずれの文字列が連続しており、
    // その後に「.png」「.jpg」「.jpeg」「.bmp」.gif」のいずれかの文字が続いていれば、
    // 画像とみなしている。
    // 厳密性は全くないが、「あなただけが利用する置換法則」なので、
    // あなたが要求する範囲を満たす正規表現ならなんでもよいのである。
    var re = /[a-zA-Z0-9_\\\/]+\.(png|jpe?g|bmp|gif)/g;

    // htmltext内に対象の「re」に当てはまる箇所を発見する度に、
    // 正規表現キャプチャーを引数として、image_regex_replacerを呼び出す。
    // 正規表現キャプチャーとは「(...)」に当てはまった中身のこと。
    htmltext = htmltext.replace(re, image_regex_replacer );
    return htmltext;
}

// $0はマッチした全体、$1は１つめの(...)、よって上の正規表現だと、「拡張子」に相当するのが１つめ
// $2は今回は利用していない。
function image_regex_replacer($0,$1,$2) {

    // マッチしてれば
    if ($0) {
        // 現在のカレントディレクトリはどこ？(=原則ファイルを開いている場所)
        // より正確には、filnameをグローバル変数にコピーし、clr.System.IO.Path.GetDirectoryName(...)などを利用する。
        var currentdir = clr.System.IO.Directory.GetCurrentDirectory();

        // イメージファイルのフルパスを求める。
        var imgfilefullpath = currentdir + &quot;/&quot; + $0;

        // そのファイルが実際にあれば…
        if ( clr.System.IO.File.Exists(imgfilefullpath) ) {
            // HTMLとして画像を描画できるように、イメージタグに変換する。
            var ret = $0;
            ret += &quot;&lt;br&gt;&lt;img src='&quot; + currentdir + &quot;/&quot; + $0 + &quot;'&gt;&lt;br&gt;&quot;;
            ret += &quot;拡張子&quot; + $1 + &quot;&lt;br&gt;&quot;

            return ret;

        // 無ければ、(not found)という文字列でもくっ付けておく。
        } else {
            return $0 + &quot;(not found)&quot;;
        }
    }

    return &quot;&quot;;
}

)JSCRIPT&quot;
);

#_ = dllfuncw( #dll, &quot;Show&quot;, hidemaruhandle(0) );
</pre></div>
    <p>このようにすることで、アルゴリズムはそのままに、「編集テキスト全体」ではなく、<br>
    「選択しているテキスト」に対して同様の処理をするようになりました。<br>
    </p>
    <p>ライブプレビューですので、選択範囲をどんどん変えていくと、<br>
    描画の中身も変わっていくことを確認してみましょう。</p>
</ul>