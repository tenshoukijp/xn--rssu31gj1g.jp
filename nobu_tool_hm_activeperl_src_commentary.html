%(hilight)s
<h2><i class="fa fa-book fa-fw"></i>hmPerl.dllのソースの要点解説</h2>

<ul class="checklist">
    <li>
    <h3>概要</h3>
    <p>hmPerl.dllのソースの要点解説となります。<br>
    秀丸エディタ v8.66で追加された各種APIや機能は、どのように利用すれば良いのか、その理解に役立ててください。</p>

    <li>
    <h3>hidemaruexe_export系</h3>
    <p>まずは、「秀丸本体からexportされている関数群」をdllで利用可能とするため、インポートしています。<br>
    いくつかの関数はラップ関数を用意した方がいいので、そのようにしています。</p>
    <ul class="pointlist">
        <li>
        <h4>hidemaruexe_export.h</h4>
        <p>ソースファイル自体にコメントが豊富についています。</p>

        <p>この中で極めて重要な働きをする関数があります。<br>
        それが「Hidemaru_GetDllFuncCalledType」です。</p>
        <h4>Hidemaru_GetDllFuncCalledType関数の多数の働き</h4>
        <ul class="arrowlist">
            <li>
            <h5>①どのように「loaddll」されたのか</h5>
            <p>「loaddll文」なのか、「loaddll関数で何か値と束縛されたのか」を取得することが可能です。<br>
            この情報があれば、dllは自分自身に対して秀丸マクロを発行できるため、<br>
            ユーザーのマクロ記述に頼らない自由な自立情報伝達が可能となるのです。</p>
            <li>
            <h5>②適切な方法で関数が呼ばれたか</h5>
            <p>関数の「返り値の型」や「引数の型」を取得をもとに、「関数の呼び方」が想定どおりのものか、チェックが可能です。<br>
            ありがちな不正な呼び出しを防止することが可能です。</p>
            <li>
            <h5>③関数オーバーロード</h5>
            <p>関数が呼ばれた際に、引数が「数値」か「文字列」か判断可能なので、<br>
            「数値」でも「文字列」でもどちらでも機能する関数を作成することが可能です。</p>
            <li>
            <h5>④可変引数の関数</h5>
            <p>引数として渡された数を取得できますので、可変的な引数を持つ関数を作成することが可能です。<br>
            vsprintf関連の情報を与える必要もありません。</p>
            <li>
            <h5>⑤typeof … 秀丸上のとある変数やシンボルの自動型チェック</h5>
            <p>関数へと引数を渡した後に、その型を判別できるわけですから、<br>
            dllからは本来見えない、「秀丸マクロのシンボルの型」を自動判別することが可能です。</p>
        </ul>
        <p>hmPerlでは、Perl自体が記述できますので、④以外の全ての機能を利用しています。</p>
        <li>
        <h4>hidemaruexe_export.cpp</h4>
        <p>GetModuleHandle(NULL)などを利用して、一気にHidemaru.exeのハンドルを取得しても良いのですが、<br>
        一応の情報を管理するものとして、Hidemaru.exeのフルパス取得 ⇒ ハンドル取得 ⇒ Export関数を取得、<br>
        というように、手順を追って値を保持していっています。</p>
        <p>「Hidemaru_GetCursorPosUnicode」は複数箇所で登場するため「Hidemaru_GetCursorPos」という形で、このクラスでラップしています。<br>
        他の関数もソース中に何回も出現するようであれば、この「CHidemaruExeExport」でラップ関数を作成するのが良いでしょう。</p>
    </ul>
    <li>
    <h3>self_dll_info系</h3>
    <ul class="pointlist">
        <li>
        <h4>self_dll_info.h</h4>
        <p>hmPerl.dllそのものの情報の保持です。<br>
        ハンドルとdll自体のフルパスを保持しています。</p>
        <p>「iSelfBindedType」という珍しい値が保持されています。<br>
        このdllが秀丸マクロからどのような形でloaddllされたのかの情報です。<br>
        <h4>なぜこのような情報が必要なのか？</h4>
        <p>「秀丸マクロ」と「hmPerl.dll」の間で「自動的に値をやり取りする」ためです。</p>
        <div class="code"><pre class="brush:csharp">
① loaddll hidemarudir + @"hmPerl.dll";
</pre></div>
        <p>というdllのロード方法と、</p>
        <div class="code"><pre class="brush:csharp">
② #PL = loaddll(hidemarudir + @"hmPerl.dll");
</pre></div>
        <p>という２種類のdllのロードの仕方があります。</p>
        <p>秀丸マクロから、hmPerl.dllへと値を伝達するためには、<br>
        hmPerl.dllは、dll自身で秀丸マクロを発行し、dllfuncwやdllfuncstrwなどを利用して、<br>
        自分自身へと値を渡す必要があります。</p>
        <p>この時に、一体hmPerl.dllが「①」か「②」か「呼ばれた形式」に合わせて、 マクロを発行する必要があり、<br>
        ②の場合は、その#PLの中身の数値も把握する必要があります。</p>
        <p>当サイトの管理人は、この値を「dllの束縛タイプ」及び「dllの束縛値」と呼んでおり、<br>
        いわゆる<span class="negative">dllのハンドル(メモリアドレス)の値とは「異なる」秀丸独自の管理値</span>です。</p>
        <p><span class="negative">このことは極めて重要なことで、理解があやふやではいけません。</span><br>
        C++のdll内部から秀丸マクロを実行するためには、必ずこの点の理解が欠かせません。</p>
        <li>
        <h4>self_dll_info.cpp</h4>
        <p>「Hidemaru_GetDllFuncCalledType(-1)」によってloaddllのタイプを得ることができます。</p>
    </ul>
    <li>
    <h3>dllfunc_interface系</h3>
    <ul class="pointlist">
        <li>
        <h4>dllfunc_interface.cpp</h4>
        <p>この中で注目すべきは、「DoString」関数のみです。<br>
        </p>
        <ul class="arrowlist">
            <li>
            <h5>関数の使用法の正当性のチェック</h5>
            <p>Hidemaru_GetDllFuncCalledType(0)を利用して返り値の型の正しさをチェック、<br>
            Hidemaru_GetDllFuncCalledType(1)を利用して、引数の型の正しさをチェック、<br>
            これらにより、DoString関数の迂闊な使用方法の間違いを防止しています。<br>
            (主としてdllruncwの「w」が抜けることが多いのでそのチェックの意味合いが強いでしょう)</p>
            <li>
            <h5>Perl実行時にエラーが発生した時の情報補強</h5>
            <p>Evalのエラーは、実際の場所を少しつかみにくくなる傾向があるため、<br>
            わかりやすい表示にしています。</p>
        </ul>
    </ul>
    <li>
    <h3>perlez_engine系</h3>
    <ul class="pointlist">
        <li>
        <h4>perlez_engine.h</h4>
        <p>ここはPerlEzエンジン独特なところです。<br>
        C++11の機能によって、具体的な型の記述が不要となったので、記述がスッキリしたと言えるでしょう。</p>
        <li>
        <h4>perlez_engine.cpp</h4>
        <p>PerlEz.dllというdllの読み込み、及び、そのdll内にある関数ポインタを取得しています。<br>
        又、「プロパティ的なものへの文字列でのアクセス方法の記述」がPerlでどのようにするのが理想的なのか、<br>
        なかなか結論を見いだせなかったため、hmPerl.pmという形で各自がカスタム可能とするスタイルにしました。</p>
    </ul>
    <li>
    <h3>perlez_magical_scalar系</h3>
    <p>ここもActivePerlのPerlEz独特な処理となっています。<br>
    </p>
    <ul class="pointlist">
        <li>
        <h4>古さを感じさせる仕組み</h4>
        <p>2016年現在の主流は、組み込み言語を使う時には、<br>
        ベースとなる「C++やC#のコンパイル系言語」 ⇔ 「組み込みScript言語」において、<br>
        「変数・関数・クラス・インスタンス・メソッド」等を問わず、<br>
        お互いに「ほぼその構造のまま」やり取りできるのが主流ですが、</p>
        <p>PerlEzでは古風にも</p>
        <ul>
            <li>「グローバルシンボルに対して、Set/Getのフック関数」
            <li>「その場でScript文をEvaluate」
            <li>「関数をシンボルで名指しで指定してパラメタを与えて実行」
        </ul>
        <p>と言った形に集約されています。</p>
        <li>
        <h4>perlez_magical_scalar.h</h4>
        <ul>
            <li>フックするためのGet/Setの共通関数
            <li>「hmPerl.pm」へと出している各関数が宣言されています。
        </ul>
        <li>
        <h4>perlez_magical_scalar.cpp</h4>
        <ul class="arrowlist">
            <li>
            <h5>CPerlEzMagicalScalar::Hm::Macro::Get::VarSimbol()</h5>
            <p>秀丸上の「変数やシンボル(filenameやx)」の値を、hmPerlのC++層へと読み込み、最終的にはPerl層へと返す処理となっています。<br>
            ・最初に、hmPerl.dll自体に用意してある、引数の型を問わない「SetDynamicVar」という関数に対して、変数を引数として渡します。<br>
            ・対象の値が「数値」か「文字列」かに応じて処理を分けて、最終的にはPerl層へと返しています。</p>

            <li>
            <h5>SetDynamicVar</h5>
            <p>「dllfunc_interface_internal.cpp」に定義されています。</p>
            <p>引数が「const void* dynamic_value」となっており、「数値」でも「文字列」でも一端は、引数を受け取ります。<br>
            「Hidemaru_GetDllFuncCalledType(1)」によって、その型を調べ、情報を格納しておきます。<br>
            この情報を利用することで、スクリプト言語に相応しい「型を自動的に吸収する処理」を実現しています。</p>
            <li>
            <h5>CPerlEzMagicalScalar::Hm::Edit::Set::TotalText(...)</h5>
            <li>
            <h5>CPerlEzMagicalScalar::Hm::Edit::Set::SelectedText(...)</h5>
            <li>
            <h5>CPerlEzMagicalScalar::Hm::Edit::Set::LineText(...)</h5>
            <p>これら３つの関数は処理がほとんど同じです。</p>
            <p>「PushStrVar」関数によって、一端hmPerl.dll内へと値をストックし、<br>
            EvalMacroでhmPerl.dll自身のPopStrVar関数を実行することで、値をhmPerl⇒マクロ側へと吐き出しています。</p>
            <p>「insert dllfuncstrw(...)」といったように、insert の引数として関数の返り値をダイレクトに指定することで、<br>
            「秀丸マクロの変数のメモリ上限」にひっかからないようにすることが出来ます。</p>
            <li>
            <h5>CPerlEzMagicalScalar::Hm::Macro::Set::VarValue(...)</h5>
            <p>Perl側から指定された秀丸マクロ上の変数シンボルに、値を設定する処理です。</p>
            <p>幸い、書き込み可能な変数の場合は、秀丸マクロは、「#***」と先頭に「#」があれば数値、<br>
            「$****」と先頭に「$」があれば、文字列ですので、それによって処理を分けています。</p>
            <p>「Push***Var」関数によって、一端hmPerl.dll内へと値をストックし、<br>
            EvalMacroでhmPerl.dll自身の「Pop***Var」関数を実行することで、値をhmPerl⇒マクロ側へと吐き出す、というわけです。</p>
        </ul>
    </ul>
</ul>